Lab 2: Memory Management实习报告
===================
1100016639 信息科学技术学院 吕鑫

---

目录
-------------
<!--toc-->


----
总体概述
-------------

本次Lab针对内存管理，从物理页管理，到建立页表，再到内核地址映射，逐步建立起整个虚存系统。


----
完成情况
-------------------


### 任务完成列表

|Exercise 1|Exercise 2|Exercise 3|Exercise 4|Exercise 5|
|:--:|:--:|:--:|:--:|:--:|
|√   | √  | √  | √  | √  |


|Challenge 1|Challenge 2| Challenge 3 | Challenge 4|
|:--:|:--:|:--:|:--:|
|√   | √  | √  | √  |


----
### Part 1: Physical Page Management

第一部分主要是对物理内存页的管理。

在做Lab之前，需要对物理内存和虚拟内存的分布进行仔细的探究，否则内存分配很容易出问题。

物理内存的基本分布情况在Lab 1里已经有所提及，我们知道物理内存主要被分为两部分**Low Memory**以及**Extended Memory**。但在进入内核后，有些东西已经载入进这些内存了，如内核代码，回顾一下Lab 1的内容可知，从上电到进入内核，一共经历了下列过程：

- 一开始，CPU被指定从`0xffff0`处执行指令，这个地址处于**BIOS区**
- BIOS完成自检、设备初始化等过程后，跳转到`0x7c00`处开始执行Boot Loader的代码，这块代码处于**Low Memory区**
- Boot Loader加载内核ELF Header至`0x1000`处，根据Header信息读取内核的每一节到内存中。目前为止还是处于**Low Memory区**
- Boot Loader读取完内核到内存中，跳转到`0x10000c`处开始执行内核代码，这部分代码处于**Extended Memory**区
- 开始执行内核代码后，上述Boot Loader、内核的ELF Header等就不再需要了，作为空闲内存可被分配
- 物理内存的第一页（`0x0000`~`0x1000`）被用作存储中断描述符表IDT

综上，我们可以画出内核加载完之后的物理内存分布：

<img src="http://ww1.sinaimg.cn/large/69cb49bcjw1eq2859buuuj20to0nmgny.jpg" width="70%"/>

从下往上，先是**中断描述符表IDT**，然后是一块空闲区，再然后是**BIOS ROM**、**16-bit devices, expansion ROM**、**VGA Display**等，这些连续的地址统一称为**IO Hole**。接着是内核代码以及内核用于内存管理的数据结构（一级页表等）。

红色标注的是已分配内存，绿色标注是可分配的物理内存。

----
##### Exercise 1
> In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).
> 
`boot_alloc()`
`mem_init()` (only up to the call to `check_page_free_list(1)`)
`page_init()`
`page_alloc()`
`page_free()`

1. `boot_alloc()`


   	此函数在内核初始化虚存系统时，用于申请内存。参数n是要申请的字节数，返回值是申请到的内存地址。因此，按照注释的提示，简单地返回当前的`nextfree`值，并更新nextfree值为`ROUND(nextfree+n, PGSIZE)`即可。

	```c
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
	nextfree = ROUNDUP(nextfree + n, PGSIZE);

	return result;
}
	```

2. `mem_init()`

	 这个函数有两个主要功能：**初始化页表**和**内存映射**，当然在exercise 1中只需要完成页表的初始化就可以了。

     要补充的代码段如下，申请了一段内存空间用于储存页表，并全部清零：
 	```
	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
	memset(pages, 0, sizeof(struct PageInfo) * npages);
 	```

3. `page_alloc()`
  
   	这个函数为每个页面的`PageInfo`结构进行初始化，并建立起空闲页链表`page_free_list`。

   	为此我们需要理清那些内存是已被占用的，哪些是可用的。根据上文的内存分布情况可知：

	- 第一页（`[0, PGSIZE)`）已被占用，用于中断描述符表等其他BIOS结构
	- 第二页到**IO Hole**中间的这一段（`[PGSIZE, npages_basemem * PGSIZE)`）内存可用
	- **IO Hole**（`[IOPHYSMEM, EXTPHYSMEM`）不可用
	- 内核数据结构（页表等）已占用的内存段不可用

  	前三项都有明确的变量、宏帮助定位，而第四项如何确定呢？只需要`boot_alloc(0)`即可，它会返回当前下一块空闲内存的初始地址（虚拟地址），我们将这个地址减去`KERNBASE`，就知道内核当前占用了多少内存了。再然后，目前的内存映射机制是把虚拟地址`[KERNBASE, KERNBASE + 4MB)`映射到物理地址`[0, 4MB)`上，所以这个差值实际上就是下一块空闲内存的实际物理地址。

  	综上，对于空闲内存，我们初始化它的引用数为0，并加入到空闲链表中。而已占用的内存，根据注释，它们的引用数没有意义，无需初始化。具体代码如下：
  
  	```c
void
page_init(void)
{
	size_t i;
	// [PGSIZE, npages_basemem * PGSIZE) is free
	for (i = 1; i < npages_basemem; ++i) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	// boot_alloc(0) denotes the start virtual address of the current free mem
	for (i = ((uint32_t)boot_alloc(0) - KERNBASE) / PGSIZE; i < npages; ++i) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
  	```

4. `page_alloc()`

  	这个函数的作用是从空闲链表中分配一页物理页。参数`alloc_flag`指明是否要清空页面。

  	功能非常直观，容易实现，代码如下：
  	
  	```c
struct PageInfo *
page_alloc(int alloc_flags)
{
        struct PageInfo *pp;

        pp = page_free_list;
        // return NULL if we're out of mem
        if (!pp)
                return NULL;
        page_free_list = pp->pp_link;
        pp->pp_link = NULL;
        // clean the page if ALLOC_ZERO is set
        if (alloc_flags & ALLOC_ZERO)
                memset(page2kva(pp), 0, PGSIZE);
        return pp;
}
  	```

5. `page_free()`
  
	  这个函数释放一个物理页，只需先检查该页是否可以释放，之后将其插入空闲链表中即可，代码如下：
	  
	  ```c
void
page_free(struct PageInfo *pp)
{
    // Hint: You may want to panic if pp->pp_ref is nonzero or
    // pp->pp_link is not NULL.
    if (pp->pp_ref || pp->pp_link) {
            panic("page_free: Invalid page to free!");
            return;
    }

    pp->pp_link = page_free_list;
    page_free_list = pp;
}
	  ```
	  
	  至此Part 1全部完成，能通过`check_page_alloc()`函数了。

----
### Part 2: Virtual Memory
 


#### Virtual, Linear, and Physical Addresses

这部分开始构建虚存，先用下图回顾一下x86下的寻址机制。

<img src="http://ww1.sinaimg.cn/large/69cb49bcjw1eq5d737559j20ua0p2acz.jpg" width="70%"/>

可见，整个流程是虚拟地址先经过**分段机制**转化成线性地址，之后再通过**分页机制**转化为物理地址。

- **分段机制**：在`boot/boot.S`中，我们已经在GDT中将所有段基址全部设为0，这使得分段机制失去了作用，因此线性地址永远等于虚拟地址。
- **分页机制**：在`inc/mmu.h`中，详细标明了JOS中的分页机制。基本如上图所示，采用的是二级页表结构，一个虚拟地址的前10位是一级页表（Page Directory）索引，后面10位是二级页表（Page Table）索引，最后12位为页中偏移（offset）。

----
##### Exercise 3
> While GDB can only access QEMU's memory by virtual address, it's often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU monitor commands from the lab tools guide, especially the xp command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).

这个exercise教我们如何进入并使用QEMU的monitor，一开始怎么也进不去，后来一顿乱按才试出，原来是先按`Ctrl+A`，释放后再按`C`……。

qemu monitor进入后如下：

<img src="http://ww1.sinaimg.cn/large/69cb49bcgw1eq486x8xlzj218g0tu7dr.jpg" width="70%"/>

之后，Lab 2告诉我们了JOS中几种地址类型：`T*`以及`uintptr_t`是虚拟地址，`phyaddr_t`是物理地址。

----
##### Question
> 
Assuming that the following JOS kernel code is correct, what type should variable x have, `uintptr_t` or `physaddr_t`?

```c
mystery_t x;
char* value = return_a_pointer();
*value = 10;
x = (mystery_t) value;
```

value变量是`char *`类型的，这是一个虚拟地址，显然`x`也是，因此它的类型是`uintptr_t`。

----

#### Reference counting

这部分主要提醒我们，在`page_alloc()`之后，要记得增加这个page的reference count。

----

#### Page Table Management


这部分开始，让我们继续填充几个函数，来管理页表。

上文已提到，JOS中采用的是二级页表结构，第一级为**页目录（Page Directory）**，第二级为**页表（Page Table）**，因此查询一个虚拟地址va的页表项时，由于线性地址等于虚拟地址，因此直接根据va高10位得到页目录偏移，从一级页表里得到页表物理地址，再根据va接下去的10位得到页表偏移，得到页物理地址，最后根据最后12位页内偏移，得到最终的物理地址，如下图所示。

<img src="http://ww4.sinaimg.cn/large/69cb49bcjw1eq5dgen3sdj20u40hw76i.jpg" width="70%"/>

为了方便我们实现页表管理，`inc/mmu.h`提供了几个有用的宏来帮助我们操作地址：

- `PGNUM(la)`：获取一个线性地址的页号
- `PDX(la)`：获取一个线性地址的页目录偏移
- `PTX(la)`：获取一个线性地址的页表偏移
- `PGOFF(la)`：获取一个线性地址的页内偏移
- `PTE_ADDR(pte)`：获取一个页目录项中的物理地址

另外，由于现在还没有通过`%cr3`激活页表，因此现在的地址映射依然是之前的`[KERNBASE, KERNBASE + 4MB)`到`[0, 4MB)`，一一映射。为了方便实现当前物理地址、页信息结构、虚拟地址之间的转换，`kern/pmap.h`中也提供了一些有用的宏和函数：

- `PADDR(kva)`：获取一个虚拟地址对应的物理地址
- `KADDR(pa)`：获取一个物理地址对应的虚拟地址
- `page2pa(pp)`：获取页信息结构`pp`所对应的物理页初始地址
- `pa2page(pa)`：获取一个物理地址所在的物理页的页信息结构`pp`
- `page2kva(pp)`：获取页信息结构`pp`对应的虚拟地址

##### Exercise 4
> In the file kern/pmap.c, you must implement code for the following functions.
> 
> `pgdir_walk()`
> `boot_map_region()`
> `page_lookup()`
> `page_remove()`
> `page_insert()`

1. `pgdir_walk()`

 这个函数的功能是根据传入的虚拟地址`va`，返回它对应的页表项，`create`参数标明若页表项不存在时是否创建。这个函数可以说是页表管理的关键，之后的几个函数几乎全部需要使用它，因此需要谨慎编写。

 需要注意的地方是，在创建页表项使用`page_alloc()`后，需立即将这个页的`pp_ref`加1。

 ```cpp
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	struct PageInfo *pp;
	pte_t *pte;
	// check if pgdir is NULL
	if (!pgdir)
		return NULL;
	// check if the page table page is not allocated
	pgdir = &pgdir[PDX(va)];
	if (!*pgdir) {
		// return NULL if create == false
		if (!create)
			return NULL;
		// allocate a new page for page table page
		pp = page_alloc(ALLOC_ZERO);
		// return NULL if allocation fails
		if (!pp)
			return NULL;
		// increment its ref
		pp->pp_ref++;
		// set permission flags
		*pgdir = page2pa(pp) | PTE_P | PTE_U | PTE_W;
	}
	pte = (pte_t *) KADDR(PTE_ADDR(*pgdir));

	return pte + PTX(va);
}
 ```

2. `boot_map_region()`

  这个函数完成了虚拟地址到物理地址的映射过程，它将`[va, va + size)`的虚拟地址空间映射到`[pa, pa + size)`的物理地址空间。利用`boot_map_region()`函数很容易实现这个映射。

 ```cpp
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	size_t i;
	pte_t *pte;
	for (i = 0; i < size; i += PGSIZE) {
		// get the pte 
		pte = pgdir_walk(kern_pgdir, (char *)(va + i), 1);
		// write the pte entry 
		if (pte != NULL) {
			*pte = (pa + i) | perm | PTE_P;
		}

	}
}

 ```

3. `page_lookup()`

 这个函数根据传入的虚拟地址`va`返回它映射的物理页信息，同样利用`pgdir_walk()`很容易实现。

  ```cpp
  struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
		// Fill this function in
		pte_t *pte;
		pte = pgdir_walk(pgdir, va, 0);
		if (!pte || !*pte)
			return NULL;
		if (pte_store) {
			*pte_store = pte;
		}
		return pa2page(PTE_ADDR((void*)(*pte)));
}
  ```

4. `page_remove()`

  这个函数取消虚拟地址`va`对应的物理页的映射关系，利用`page_lookup()`找到这个物理页，并使它无效即可，注意同时要将tlb中的对应条目无效化。

 ```cpp
void
page_remove(pde_t *pgdir, void *va)
{

		struct PageInfo *pp;
		pte_t *pte;
		pp = page_lookup(pgdir, va, &pte);
		if (!pp)
			return;
		tlb_invalidate(pgdir, va);
		page_decref(pp);
		*pte = 0;
}
 ```

5. `page_insert()`

  这个函数将虚拟地址`va`映射到`pp`所对应的物理地址，若`va`已被映射，则应利用`page_remove()`先取消当前的映射。

 需要注意的一点就是，在调用`page_remove()`取消映射后，有可能那个物理页变为了空闲页被加入链表中，这样如果我们重新映射相同的地址，一定要**检查链表头是否是刚刚释放的物理页**，否则空闲链表的维护将会出错。

 ```cpp
 int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
		pte_t *pte;

		page_remove(pgdir, va);
		pte = pgdir_walk(pgdir, va, 1);
		if (!pte)
			return -E_NO_MEM;
		*pte = page2pa(pp) | perm | PTE_P;
		// if the page we just removed becomes a free page, remove it from free list
		if (pp->pp_ref == 0) {
			page_free_list = pp->pp_link;
			pp->pp_link = NULL;
		}
		pp->pp_ref++;
		return 0;
}
 ```

至此，Exercise 4的内容全部完成，可以通过`check_page()`了。

-----
### Part 3: Kernel Address Space

这一部分最终完成地址的映射，构建好整个虚拟地址空间`[0, 4GB)`的映射，并开始实行完整的分页机制。

`inc/memlayout.h`里对整个虚拟地址空间的划分有完整的描述：

<img src="http://ww1.sinaimg.cn/large/69cb49bcjw1eq5pdhq5c3j20qq19mgsk.jpg"  width="70%"/>

---
#### Permissions and Fault Isolation
为了保护内核空间不被用户态程序访问，需要在页表项里添加权限位。

从图中可看出，`[0, UTOP)`供用户态使用，用户态可读可写；`[UTOP, ULIM)`是系统环境和页面管理，用户和内核均只可读不可写。`[ULIM. 4GB)`分配给内核态，用户态不可读不可写。

---
#### Initializing the Kernel Address Space
了解权限后，我们便开始对虚拟内存进行映射。

##### Exercise 5
> Fill in the missing code in mem_init() after the call to check_page().


先是处理`[UPAGES, UPAGES + PTSIZE)`这一段，注释里说了，这段存的是pages数组的一个镜像（image），一开始对image这个词很疑惑，不知道要做什么。后面才明白，就是把`[UPAGES, UPAGES + PTSIZE)`映射到pages数组对应的物理内存。也就是说，现在有**两段**虚拟内存映射在这段物理内存上，一段起始地址是`pages`，另一段是`UPAGES`。

现在就很好理解注释中两段权限的含义了，`UPAGES`开头的那段虚拟内存设成`R-/R-`，而`pages`这段虚拟内存设成`RW/--`。事实上，`pages`地址目前是处于`KERNBASE`之上，之后我们会把这之上内存的权限一并设置，因此这里先不用考虑`pages`。

代码：

```cpp
	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
```

接下来是内核栈空间的映射，和刚刚类似的方法，将`[KSTACKTOP - KSTKSIZE, KSTACKTOP)`映射到`bootstack`所映射的同一块物理地址上。

```cpp
	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);
```

最后就是映射内核空间`[KERNBASE, 4GB)`了，这段空间的标志位全部设为`RW/--`，来保护内核。这里有一个小细节，注释里也说了这一段的大小是`2^32 - KERNBASE`，而`2^32`这个数是超过`int`的表示范围的，为此我们需要计算出这个差值：

`2^32 - KERNBASE = (2^32 - KERNBASE) % 2^32 = -KERNBASE`

```cpp
	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	boot_map_region(kern_pgdir, KERNBASE, -KERNBASE, 0, PTE_W);
```

至此，Lab 2的基础部分已经完成，运行`make grade`已能通过所有test。

<img src="http://ww2.sinaimg.cn/large/69cb49bcjw1eq692g3y07j20m90evdhj.jpg" width="70%"/>


##### Question

> What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:

 利用QEMU Monitor的`info pg`命令，可以很清楚地看到哪几个Page Directory已经有了值，就可以轻松填写该表格了。

 <img src="http://ww4.sinaimg.cn/large/69cb49bcjw1eq6cnqmd84j20mc0evdjf.jpg" width="70%"/>

 Entry	| Base Virtual Address	| Points to (logically) |
|:--- | :--- | :---
1023	| 0xffc00000	| Page table for top 4MB of phys memory
...| ... | ...
960	| 0xf0000000	| Page table for `[0x0, 0x003fffff)` phys memory 
959	| 0xefc00000	| **Kernel Stack** 
958	| 0xef800000	|?
957 | 0xef400000 | **Cur page table** |  
956 | 0xef000000 | **RO PAGES**
955 | 0xeec00000 | ?
... | ... | ...
1	|0x00400000	|?
0	|0x00000000	| ?


> We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

页表项中的`PTE_U`位标明用户态程序是否可以访问该页，内核空间没有设置这一位，用户因此不能访问这部分内存。

> What is the maximum amount of physical memory that this operating system can support? Why

回顾一下上面Virtual Memory Layout那张图，`[UPAGES, UVPT)`这段存储的是所有页的`PageInfo`结构，每一个物理页都要在其中有一个这样的结构，因此这段的大小实际上就决定了JOS操作系统最多能支持的物理内存大小。

`inc/memlayout.h`中指出这段的大小是`PTSIZE`，`inc/mmu.h`定义了它为`PGSIZE * NPTENTRIES`，再继续探查可知，这个值的大小为`2^22 byte`。另外，一个`PageInfo`结构的大小是`8 byte`（一个指针和一个32位整数），每个`PageInfo`结构对应着一个`4 KB = 4096 byte`的页面。

综上，最多能支持的物理内存为`2^22 / 8 * 4096 = 2^31 byte = 2 GB`

> How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

最大物理内存是`2 GB`，页数为`2^31 / 4K = 512 K`，每页要用一个`8 byte`的`PageInfo`结构来管理，需要`512K * 8 = 4 MB`。

使用大页机制可以使overhead降低。

> Revisit the page table setup in `kern/entry.S` and `kern/entrypgdir.c`. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

`entry.S`中的一句跳转指令让`%eip`变成`KERNBASE`上的地址：
```
	# Now paging is enabled, but we're still running at a low EIP
	# (why is this okay?).  Jump up above KERNBASE before entering
	# C code.
	mov	$relocated, %eax
	jmp	*%eax
```

至于为什么在打开分页机制后，我们还能在原来的低地址`%eip`上继续正常运行，是因为`entrypgdir.c`中将两段虚拟地址空间`[0, 4MB)`和`[KERNBASE, KERNBASE + 4MB)`映射到同一个物理地址空间`[0, 4MB)`：

```cpp
pde_t entry_pgdir[NPDENTRIES] = {
	// Map VA's [0, 4MB) to PA's [0, 4MB)
	[0]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,
	// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
	[KERNBASE>>PDXSHIFT]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W
};
```

这样映射，打开了分页机制后，低地址被还是被映射到了与原来相同的物理地址，因此能够正确执行。

##### Challenge 1
> We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the **PTE_PS** ("Page Size") bit in the page directory entries. This bit was not supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to **Volume 3 of the current Intel manuals**. Make sure you design the kernel to use this optimization only on processors that support it!


Intel手册中对4MB页表的实现有着详细的说明，一个使用了4MB页的虚拟地址的寻址方式为：从虚拟地址的前10位得到页目录偏移（Page Directory Index），之后从一级页表（Page Directory）到页目录项。最后从页目录项中的前10位取得物理页起始地址，从虚拟地址的后22位取得页偏移（Offset），两者一加就是最终的物理地址。结合下面两张图便很容易理解。

4MB页寻址方式：

<img src="http://ww1.sinaimg.cn/large/69cb49bcjw1eq8ikdlk7qj20ua0gs40d.jpg" width="70%"/>

4MB页表结构：

<img src="http://ww4.sinaimg.cn/large/69cb49bcjw1eq8ise4kb4j20tk0gyjub.jpg" width="70%"/>

为此在JOS中新定义了几个宏来方便管理4MB页：

```cpp
// bytes mapped by a larger page (4MB)
#define LPGSIZE		4194304

// offset in 4MB page
#define LPGOFF(la)  (((uintptr_t)(la)) & 0x003FFFFF)

// Address in 4MB page table
#define LPTE_ADDR(lpte) ((physaddr_t)(lpte) & 0xFFC00000)
```

那么要修改哪些函数才能实现4MB页表呢？从4KB到4MB页表，实际上是映射方式的改变，因此我们修改`boot_map_region()`函数：

```cpp
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	size_t i;
	pte_t *pte;

	// 4MB pages mapping
	if (perm & PTE_PS) {
		for (i = 0; i < size; i += LPGSIZE) {
			pte = pgdir + PDX(va + i);
			if (pte) {
				*pte = (pa + i) | perm | PTE_P;
			}
		}
		return;
	}
	// 4KB pages mapping
	for (i = 0; i < size; i += PGSIZE) {
		// get the pte 
		pte = pgdir_walk(kern_pgdir, (char *)(va + i), 1);
		// write the pte entry 
		if (pte != NULL) {
			*pte = (pa + i) | perm | PTE_P;
		}

	}
}

```

还有一个`checkva2pa()`函数有必要改，这个函数根据给定的虚拟地址，在页表中查询，返回对应的物理地址。由于使用了4MB大页，寻址方式相应地发生了改变，因此需要修改：

```
static physaddr_t
check_va2pa(pde_t *pgdir, uintptr_t va)
{
	pte_t *p;

	pgdir = &pgdir[PDX(va)];
	if (!(*pgdir & PTE_P))
		return ~0;
	// 4MB pages
	if (*pgdir & PTE_PS)
		return LPTE_ADDR(*pgdir) | LPGOFF(va);
	// 4KB pages
	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
	if (!(p[PTX(va)] & PTE_P))
		return ~0;
	return PTE_ADDR(p[PTX(va)]);
}
```

之后运行`make grade`，没有任何问题，全部通过。

```
running JOS: (1.1s) 
  Physical page allocator: OK 
  Page management: OK 
  Kernel page directory: OK 
  Page management 2: OK 
Score: 70/70
```


----
##### Challenge 2
> Extend the JOS kernel monitor with commands to:
 
----

> Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter **showmappings 0x3000 0x5000** to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.

很直观，我的实现方法是先在`monitor.c`中注册一个`mon_showmappings()`函数，里面先进行参数检查，无误后调用`pmap.c`中的`show_map_region()`函数来打印结果。

 `mon_showmappings()`主要就是参数检查，就不贴了，主要是`show_map_region()`函数：

```cpp
void
show_map_region(uintptr_t start_va, uintptr_t end_va)
{
    
    uintptr_t va;
    pte_t *pteptr;
    start_va &= ~0xfff;
    end_va &= ~0xfff;

    cprintf("Virt Addr     Phys Addr     Permission\n");
    for (va = start_va; va <= end_va && va >= start_va; va += PGSIZE) {
        pteptr = pgdir_walk(kern_pgdir, (const void *)va, 0);
        cprintf("0x%08x    ", va);
        if (!pteptr || !*pteptr) {
            cprintf("Not mapped\n");
            continue;
        }
        cprintf("0x%08x    |", PTE_ADDR(*pteptr));
        if (*pteptr & PTE_G)
            cprintf("PTE_G|");
        if (*pteptr & PTE_PS)
            cprintf("PTE_PS|");
        if (*pteptr & PTE_D)
            cprintf("PTE_D|");
        if (*pteptr & PTE_A)
            cprintf("PTE_A|");
        if (*pteptr & PTE_PCD)
            cprintf("PTE_PCD|");
        if (*pteptr & PTE_PWT)
            cprintf("PTE_PWT|");
        if (*pteptr & PTE_U)
            cprintf("PTE_U|");
        if (*pteptr & PTE_W)
            cprintf("PTE_W|");
        if (*pteptr & PTE_P)
            cprintf("PTE_P|");
        cprintf("\n");  
    }

} 
```

效果如下：

<img src="http://ww3.sinaimg.cn/large/69cb49bcjw1eq8khqwnifj20mc0ev42q.jpg" width="70%"/>

----
>  Explicitly set, clear, or change the permissions of any mapping in the current address space.

跟之前一样，在`monitor.c`中建立`mon_setperm()`检查参数，调用`pmap.c`中的`setperm()`来实现。实现很简单，用`pgdir_walk()`找到对应的pte，直接更改权限即可。

```cpp
void
setperm(uintptr_t va, int perm)
{
    pte_t *pteptr;
    int old_perm, i;
    va = ROUNDDOWN(va, PGSIZE);
    pteptr = pgdir_walk(kern_pgdir, (const void *)va, 0);
    cprintf("Virt Addr: 0x%08x\nPermissions: \n", va);
    if (!pteptr) {
        cprintf("Not mapped\n");
        return;
    }
    
    for (i = 0; i < 2; ++i, *pteptr = (*pteptr & ~0xFFF) | perm) {
        if (i == 0)
            cprintf("Old: ");
        else
            cprintf("New: ");
        cprintf("|");
        if (*pteptr & PTE_G)
            cprintf("PTE_G|");
        if (*pteptr & PTE_PS)
            cprintf("PTE_PS|");
        if (*pteptr & PTE_D)
            cprintf("PTE_D|");
        if (*pteptr & PTE_A)
            cprintf("PTE_A|");
        if (*pteptr & PTE_PCD)
            cprintf("PTE_PCD|");
        if (*pteptr & PTE_PWT)
            cprintf("PTE_PWT|");
        if (*pteptr & PTE_U)
            cprintf("PTE_U|");
        if (*pteptr & PTE_W)
            cprintf("PTE_W|");
        if (*pteptr & PTE_P)
            cprintf("PTE_P|");
        cprintf("\n");
    }
}
```

效果如下：

<img src="http://ww3.sinaimg.cn/large/69cb49bcjw1eq8np8wrbij20j00evdhl.jpg" width="70%"/>

----
> Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!

对于虚拟地址很简单，检查该虚拟地址所在页的`PTE_P`是否被设置，若被设置则直接输出该地址上的值即可。

```cpp
void
dump_virtaddr(uintptr_t start_va, uintptr_t end_va)
{
    int *va;
    pte_t *pteptr;
    start_va = ROUNDDOWN(start_va, 4);
    end_va = ROUNDDOWN(end_va, 4);
    for (va = (int*)start_va; va <= (int*)end_va; ++va) {
        cprintf("0x%08x:", va);
        pteptr = pgdir_walk(kern_pgdir, (const void *)va, 0);
        if (!pteptr || !(*pteptr & PTE_P)) {
            cprintf(" 0x????????\n");
        } else {
            cprintf(" 0x%08x\n", *va);
        }
    }
}
```

而对于物理地址则比较麻烦，因为分页机制已经开启，需要遍历页表来找到物理地址对应的虚拟地址才能输出。好在已经有了三块区域已经做了静态映射，因此根据静态映射来还原虚拟地址即可：

```cpp
void
dump_physaddr(physaddr_t start_pa, physaddr_t end_pa)
{
    uintptr_t va;
    physaddr_t pa;
    pte_t *pteptr;

    start_pa = ROUNDDOWN(start_pa, 4);
    end_pa = ROUNDDOWN(end_pa, 4);
    cprintf("%d %d\n", start_pa, end_pa);
    for (pa = start_pa; pa <= end_pa; pa += 4) {
        cprintf("0x%08x:", pa);
        if (pa < -KERNBASE)
            va = pa + KERNBASE;
        else if (pa >= PADDR(bootstack) && pa < PADDR(bootstack) + KSTKSIZE) {
            va = pa - PADDR(bootstack) + KSTACKTOP - KSTKSIZE;
        }
        else if (pa >= PADDR(pages) && pa < PADDR(pages) + PTSIZE) {
            va = pa - PADDR(pages) + UPAGES;
        } else {
            cprintf(" 0x????????\n");
            continue;
        }

        pteptr = pgdir_walk(kern_pgdir, (const void *)va, 0);
        if (!pteptr || !(*pteptr & PTE_P)) {
            cprintf(" 0x????????\n");
        } else {
            cprintf(" 0x%08x\n", *(int*)va);
        }
    }
}
```

效果如下，测试了一块静态映射的区域，可见两种方式的结果是相同的：

<img src="http://ww4.sinaimg.cn/large/69cb49bcgw1eq8ph5ukb7j20j00evdhz.jpg" width="70%"/>

----
> Do anything else that you think might be useful later for debugging the kernel. (There's a good chance it will be!)

I think nothing else might be useful later.

 

---
#### Address Space Layout Alternatives

##### Challenge 3
> Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: the technique is sometimes known as "follow the bouncing kernel." In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I/O devices in this scheme, and how the kernel would access a user environment's virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.

毫无办法。

参考了[https://github.com/cmjones/jos-mmap/blob/master/answers-lab2.txt](https://github.com/cmjones/jos-mmap/blob/master/answers-lab2.txt)

他的方法大致就是：每次用户态发生中断，去查看中断描述符表时，这时候内核设计为让**中断描述符表(IDT)**所在页移动到另一个虚拟地址，把原来它的虚拟地址空出来给用户。由于移动的位置可以是任意的，这样理论上用户态就能访问所有4GB的虚拟地址空间。

但是我觉得这种设计的效果会非常差，这样每次发生一个中断的时候，代价会非常大，搞不好晃一下鼠标都要卡。。但是想法还是值得学习的。

-----
##### Challenge 4
> Since our JOS kernel's memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose **malloc/free** facility that we can use within the kernel. This could be a problem if we want to support certain types of I/O devices that require physically contiguous buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB superpages for maximum processor efficiency. (See the earlier challenge problem about **PTE_PS**.)

**伙伴系统（Buddy System）**可以用来解决这个问题。

**思想**：将空闲内存分为大小为2的幂次的块。在申请一段内存空间 $n$ 时，先计算满足 $2^i >= n$ 最小的 $i$ ，寻找大小为 $2^i$ 的空闲块分配给它。若没有，则往上寻找空闲块，直到找到大小为 $2^j(j >i)$ 的空闲块，递归地将它分成两半，直到大小等于 $2^i$ ，最后分配这块大小为 $2^i$ 的空闲块即可。

**实现**：ICS Memory Lab已经辛苦地实现过了，这里就不实现了。。

----
感想与收获
-------------
这次Lab涉及内存管理，难度比第一次大。刚拿到Lab 2的代码时很头疼，需要理清各个文件、各个函数的相互关系，想清楚页表到底是如何建立起来的。好在MIT的教授特别善良，在代码里有非常详尽的注释，很大程度上帮助了我完成Lab。

至于Challenge，除了第二个challenge，其它都非常的challenging。第一题需要阅读Intel手册查阅大量资料才能做；第三题读下来根本毫无头绪，网上资料也少之又少；第四题虽然很容易想到做法，但是那一刻，我终于回想起了，曾经一度被Memory Lab支配的恐怖，还有囚禁于Segment Fault的那份屈辱，因此根本没想过去实现它。。

总之，Lab 2做完了，已经没有什么好害怕的了，这时只要微笑就可以了。

---
参考资料
-------------
1. **操作系统JOS实习第二次报告**，张弛
2. **Computer Systems: A Programmer's Perspective, Second Edition**, Randal E. Bryant and David R O'Hallaron.